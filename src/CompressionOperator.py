
import random as random

import tensorflow as tf

class CompressionOperator :

    # Configuration
    # -------------
    backingTensorDepth = 10
    backingTensorValueLow = 0.0
    backingTensorValueHigh = 1.0
    mutationMagnitude = .000001

    # Fitness
    fitness = 99999999

    # Product Vector Dimensions
    #   The Product vector is one dimensional in this implementation
    productVectorSize = None

    # Backing Tensor
    # --------------
    #   The backing tensor is made up of a set of rank 1 tensors (vectors).
    #   Their dimensions are always (in this implementation) 1 X N where
    #   N is the product vector size.
    #   The backing tensor can also be thought of as a rank 2 tensor where
    #   The Z dimension is described by the successive ordering of the set
    #   of rank 1 tensors.
    backingTensor = []

    def __init__(self, productVectorSize) :
        self.productVectorSize = productVectorSize
        self.generateRandomBackingTensor()

    def generateRandomBackingTensor(self) :

        #I DONT KNOW WHY THIS WORKS!!!
        self.backingTensor.clear()

        for i in range(self.backingTensorDepth) :
            backingTensorLayer = []
            for j in range(self.productVectorSize) :
                backingTensorLayer.append(random.uniform(self.backingTensorValueLow, self.backingTensorValueHigh))
            self.backingTensor.append(backingTensorLayer)

    def mutate(self, mutationRate) :
        
        for i in range(len(self.backingTensor)) :
            rank1Tensor = self.backingTensor[i]
            for j in range(len(rank1Tensor)) :
                if random.uniform(0, 1) < mutationRate :
                    if random.uniform(0, 1) < .5 :
                        rank1Tensor[j] = random.uniform(self.backingTensorValueLow, self.backingTensorValueHigh)
                    else :
                        if random.uniform(0, 1) < .5 :
                            rank1Tensor[j] = rank1Tensor[j] + self.mutationMagnitude
                        else :
                            rank1Tensor[j] = rank1Tensor[j] + self.mutationMagnitude

    # Function:
    # --------- 
    #   generateTFOperation()
    # --------------------------------------------------------------------------
    # Description:
    # ------------
    #   Generates a Tensorflow operation that represents the computation over
    #   the backing tensor of this Compression Operator.
    # --------------------------------------------------------------------------
    # Parameters:
    # -----------
    #   inputPlaceholder - A Tensorflow placeholder object that will be loaded
    #                      with the stimulus value
    # --------------------------------------------------------------------------
    # Result:
    # --------
    #   Returns a Tensorflow operation. This Tensorflow operation is the 
    #   result of building a compound operation over the vectors in the backing
    #   tensor.
    # --------------------------------------------------------------------------
    # Explanation:
    # ------------
    #   A Compression Operator is backed by a series of rank 1 tensors full of
    #   values generated by the Genetic Algorithm. The GAVC algorithm works by
    #   feeding stimuli accross this tensor in order to reproduce given product
    #   vectors. More specifically, a given stimulus value is multiplied by
    #   this backing tensor to get product vectors. Thus we need to create an
    #   operation that represents the backing tensor in 'compute' form. This
    #   is simply a series of matrix multiplication operations. This function
    #   uses the Tensorflow API to build this series of matrix multiplications.
    # --------------------------------------------------------------------------
    def generateTFOperation(self, inputPlaceholder) :

        mappingOperation = tf.multiply(inputPlaceholder, self.backingTensor[0])

        for index in range(1, len(self.backingTensor)) :
            mappingOperation = tf.multiply(mappingOperation, self.backingTensor[index])

        return mappingOperation

    def setFitness(self, fitness) :
        self.fitness = fitness

    def getFitness(self) :
        return self.fitness

    def setProductVectorSize(self, productVectorSize) :
        self.productVectorSize = productVectorSize

    def getProductVectorSize(self) :
        return self.productVectorSize

    def getBackingTensor(self) :
        return self.backingTensor

    def setBackingTensor(self, newBackingTensor) :
        self.backingTensor = newBackingTensor

    def clone(self) :
        clone = CompressionOperator(self.productVectorSize)

        clone.setFitness(self.fitness)

        clone.setProductVectorSize(self.productVectorSize)

        cloneBackingTensor = []

        for i in range(len(self.backingTensor)) :
            rank1Tensor = []

            backingTensorRank1Tensor = self.backingTensor[i]
            for j in range(len(backingTensorRank1Tensor)) :
                rank1Tensor.append(backingTensorRank1Tensor[j])

            cloneBackingTensor.append(rank1Tensor)

        clone.setBackingTensor(cloneBackingTensor)

        return clone